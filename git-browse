#!/usr/bin/env python

import curses
import os

key_bindings = {}

def bind_keys(*keys):
    def decorator(func):
        for k in keys:
            code = ord(k) if type(k) is str else k
            key_bindings[code] = func.__name__
        return func
    return decorator


class GitCommit(object):
    def __init__(self, sha, author, message):
        self.sha = sha
        self.author = author
        self.message = message


class GitFileHistory(object):
    def __init__(self, path, start_commit):
        #TODO Validate path
        #TODO Validate commit

        self.path = path

        p = os.popen('git log %s --pretty="%s" -- %s' % (
            start_commit,
            '%H%n%an%n%s%n',
            self.path,
        ))
        output = p.read().split('\n\n')

        self.commits = [GitCommit(*c.split('\n', 2)) for c in output if c]
        self._index = 0
        self._blame = None

    @property
    def current_commit(self):
        return self.commits[self._index]

    def next(self):
        if self._index <= 0:
            return False

        self._index -= 1
        self._blame = None
        return True

    def prev(self):
        if self._index >= len(self.commits) - 1:
            return False

        self._index += 1
        self._blame = None
        return True

    def blame(self):
        if self._blame:
            return self._blame

        lines = []

        p = os.popen('git blame -p %s %s' % (
            self.path,
            self.current_commit.sha,
        ))

        while True:
            header = p.readline()
            if not header:
                break

            # Header format:
            # commit_sha original_line final_line[ lines_in_group]
            sha, original_line, final_line = header.split(' ')[:3]

            line = p.readline()

            # Skip any addition headers describing the commit
            while not line.startswith('\t'):
                line = p.readline()

            lines.append((sha, line[1:], sha == self.current_commit.sha))

        self._blame = lines
        return self._blame


class GitBrowser(object):
    def __init__(self, path, commit):
        self.file_history = GitFileHistory(path, commit)
        self.path = path
        self.scroll_line = 0

    def run(self):
        self.setup_curses()

        try:
            while True:
                self.draw()
                c = self.screen.getch()

                if c == ord('q'):
                    self.teardown_curses()
                    return
                if c == ord('s'):
                    self.teardown_curses()
                    current_sha = self.file_history.current_commit.sha
                    os.execvp('git', ('git', 'show', current_sha))
                    return
                elif c in key_bindings:
                    getattr(self, key_bindings[c])()
                else:
                    curses.beep()
        except:
            self.teardown_curses()
            raise

    def setup_curses(self):
        self.screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.screen.keypad(1)

        curses.curs_set(0)

        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_BLUE, curses.COLOR_BLACK)
        self.GREEN = curses.color_pair(1)
        self.YELLOW = curses.color_pair(2)
        self.BLUE = curses.color_pair(3)

        self.commits_win = self.screen.subwin(curses.LINES-1, 8, 0, 0)
        self.code_win = self.screen.subwin(curses.LINES-1, curses.COLS-9, 0, 9)
        self.status_win = self.screen.subwin(curses.LINES-2, 0)

    def teardown_curses(self):
        curses.nocbreak()
        self.screen.keypad(0)
        curses.echo()
        curses.endwin()

    def draw(self):
        lines = self.file_history.blame()

        start = self.scroll_line
        stop = self.scroll_line + curses.LINES - 2
        visible_lines = lines[start:stop]

        self.commits_win.clear()
        self.code_win.clear()
        for i, (commit, line, current) in enumerate(visible_lines):
            self.commits_win.addstr(i, 0, commit[:7], self.YELLOW)
            self.code_win.addstr(i, 0, line[0:curses.COLS-9],
                                 self.GREEN if current else 0)

            if current:
                self.commits_win.addstr(i, 7, '+', self.GREEN)

        self.status_win.clear()
        status = '%s @ %s by %s' % (
            self.path,
            self.file_history.current_commit.sha[:7],
            self.file_history.current_commit.author,
        )
        commit_msg = self.file_history.current_commit.message[:curses.COLS-1]
        self.status_win.addstr(0, 0, status)
        self.status_win.addstr(1, 0, commit_msg)

        self.commits_win.noutrefresh()
        self.code_win.noutrefresh()
        self.status_win.noutrefresh()
        curses.doupdate()

    @bind_keys('j', curses.KEY_DOWN)
    def down(self, lines=1):
        max_scroll_line = self.max_scroll_line()
        if self.scroll_line == max_scroll_line:
            curses.beep()
            return

        self.scroll_line = min(self.scroll_line + lines, max_scroll_line)

    @bind_keys('f', ' ', curses.KEY_NPAGE)
    def page_down(self):
        self.down(curses.LINES - 2)

    @bind_keys('k', curses.KEY_UP)
    def up(self, lines=1):
        if self.scroll_line == 0:
            curses.beep()
            return

        self.scroll_line = max(self.scroll_line - lines, 0)

    @bind_keys('b', curses.KEY_PPAGE)
    def page_up(self):
        self.up(curses.LINES - 2)

    @bind_keys('g', curses.KEY_HOME)
    def home(self):
        self.scroll_line = 0

    @bind_keys('G', curses.KEY_END)
    def end(self):
        self.scroll_line = self.max_scroll_line()

    @bind_keys('n')
    def next_commit(self):
        if not self.file_history.next():
            curses.beep()

    @bind_keys('p')
    def prev_commit(self):
        if not self.file_history.prev():
            curses.beep()

    def max_scroll_line(self):
        lines = self.file_history.blame()
        return len(lines) - curses.LINES + 2


if __name__ == '__main__':
    import argparse
    import textwrap

    parser = argparse.ArgumentParser(
        description=textwrap.dedent('''\
                Browse the Git history of a single file. Similar to
                git blame, but interactive.
            '''),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent('''\
               You can use the following key commands to move around the
               interactive blame output. If you use less or vim they should
               be somewhat familiar:

                j or DOWN    move down one line
                k or UP      move up one line
                f or SPACE   move down one screen
                b            move up one screen
                G or END     move to the bottom of the file
                g or HOME    move to the top of the file

                p            move to the previous commit
                n            move to the next commit
            '''),
        )
    parser.add_argument('rev', nargs='?', default='HEAD',
                        help='a Git revision to start from (defaults to HEAD)')
    parser.add_argument('file',
                        help='the path to the file you want to examine')
    args = parser.parse_args()

    browser = GitBrowser(args.file, args.rev)
    browser.run()
