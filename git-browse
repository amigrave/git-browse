#!/usr/bin/env python

import curses
import os

key_bindings = {}

def bind_keys(*keys):
    def decorator(func):
        for k in keys:
            code = ord(k) if type(k) is str else k
            key_bindings[code] = func.__name__
        return func
    return decorator


class GitCommit(object):
    """
    Stores simple information about a single Git commit.
    """
    def __init__(self, sha, author, message):
        self.sha = sha
        self.author = author
        self.message = message


class GitBlameLine(object):
    """
    Stores the blame output for a single line of a file.
    """
    def __init__(self, sha, line, current, original_line, final_line):
        self.sha = sha
        self.line = line
        self.current = current
        self.original_line = original_line
        self.final_line = final_line


class GitFileHistory(object):
    """
    Responsible for following the history of a single file, moving around
    within that history, and giving information about the state of the file
    at a particular revision or the differences between revisions.

    Most operations are relative to the current commit, which can be changed
    with the previous and next mthods and accessed through the current_commit
    property.
    """

    def __init__(self, path, start_commit):
        #TODO Validate path
        #TODO Validate commit

        self.path = path

        p = os.popen('git log %s --follow --pretty="%s" -- %s' % (
            start_commit,
            '%H%n%an%n%s%n',
            self.path,
        ))
        output = p.read().split('\n\n')

        self.commits = [GitCommit(*c.split('\n', 2)) for c in output if c]
        self._index = 0
        self._blame = None

        self._line_mappings = {}

    @property
    def current_commit(self):
        return self.commits[self._index]

    def next(self):
        """
        Moves to the next commit that touched this file, returning False
        if we're already at the last commit that touched the file.
        """
        if self._index <= 0:
            return False

        self._index -= 1
        self._blame = None
        return True

    def prev(self):
        """
        Moves to the previous commit that touched this file, returning False
        if we're already at the first commit that touched the file.
        """
        if self._index >= len(self.commits) - 1:
            return False

        self._index += 1
        self._blame = None
        return True

    def blame(self):
        """
        Returns blame information for this file at the current commit as
        a list of GitBlameLine objects.
        """
        if self._blame:
            return self._blame

        lines = []

        p = os.popen('git blame -p %s %s' % (
            self.path,
            self.current_commit.sha,
        ))

        while True:
            header = p.readline()
            if not header:
                break

            # Header format:
            # commit_sha original_line final_line[ lines_in_group]
            sha, original_line, final_line = header.split(' ')[:3]

            line = p.readline()

            # Skip any addition headers describing the commit
            while not line.startswith('\t'):
                line = p.readline()

            lines.append(GitBlameLine(
                sha=sha,
                line=line[1:],
                current=(sha == self.current_commit.sha),
                original_line=original_line,
                final_line=final_line,
            ))

        self._blame = lines
        return self._blame

    def line_mapping(self, start, finish):
        """
        Returns a dict that represents how lines have moved between versions
        of a file. The keys are the line numbers in the version of the file
        at start, the values are where those lines have ended up in the version
        at finish.

        For example if at start the file is two lines, and at
        finish a new line has been inserted between the two the mapping
        would be:
            {1:1, 2:3}

        Deleted lines are represented by None. For example, if at start the
        file were two lines, and the first had been deleted by finish:
            {1:None, 2:1}
        """

        key = start + '/' + finish
        if key in self._line_mappings:
            return self._line_mappings[key]

        forward, backward = self._build_line_mappings(start, finish)
        self._line_mappings[start + '/' + finish] = forward
        self._line_mappings[finish + '/' + start] = backward

        return forward

    def _build_line_mappings(self, start, finish):
        forward = {}
        backward = {}

        p = os.popen('git diff --word-diff=porcelain %s %s -- %s' % (
            start,
            finish,
            self.path,
        ))

        # The diff output is in sections: A header line (indicating the
        # range of lines this section covers) and then a number of
        # content lines.

        sections = []

        # Skip initial headers: They don't interest us.
        line = ''
        while not line.startswith('@@'):
            line = p.readline()

        while line:
            header_line = line
            content_lines = []

            line = p.readline()
            while line and not line.startswith('@@'):
                content_lines.append(line)
                line = p.readline()

            sections.append((header_line, content_lines, ))


        start_ln = finish_ln = 0
        for header_line, content_lines in sections:
            # The headers line has the format '@@ +a,b -c,d @@[ e]' where
            # a is the first line number shown from start and b is the
            # number of lines shown from start, and c is the first line
            # number show from finish and d is the number of lines show
            # from from finish, and e is Git's guess at the name of the
            # context (and is not always present)

            headers = header_line.strip('@ \n').split(' ')
            headers = map(lambda x: x.strip('+-').split(','), headers)

            start_range = map(int, headers[0])
            finish_range = map(int, headers[1])

            while start_ln < start_range[0] - 1 and \
                  finish_ln < finish_range[0] - 1:
                forward[start_ln] = finish_ln
                backward[finish_ln] = start_ln
                start_ln += 1
                finish_ln += 1

            # Now we're into the diff itself. Individual lines of input
            # are separated by a line containing only a '~', this helps
            # to distinguish between an addition, a removal, and a change.

            line_iter = iter(content_lines)
            try:
                while True:
                    line_delta = 0
                    line = ' '
                    while line != '~':
                        if line.startswith('+'):
                            line_delta += 1
                        elif line.startswith('-'):
                            line_delta -= 1

                        line = line_iter.next().rstrip()

                    if line_delta == 1:
                        backward[finish_ln] = None
                        finish_ln += 1
                    elif line_delta == -1:
                        forward[start_ln] = None
                        start_ln += 1
                    else:
                        forward[start_ln] = finish_ln
                        backward[finish_ln] = start_ln
                        start_ln += 1
                        finish_ln += 1
            except StopIteration:
                pass

        # Make sure the mappings stretch the the beginning and end of
        # the files.

        p = os.popen('git show %s:%s' % (start, self.path))
        start_len = len(p.readlines())

        p = os.popen('git show %s:%s' % (finish, self.path))
        finish_len = len(p.readlines())

        while start_ln <= start_len and finish_ln <= finish_len:
            forward[start_ln] = finish_ln
            backward[finish_ln] = start_ln
            start_ln += 1
            finish_ln += 1

        return forward, backward


class GitBrowser(object):
    """
    Provides the user interface for the git browse tool.
    """

    def __init__(self, path, commit):
        self.file_history = GitFileHistory(path, commit)
        self.scroll_line = 0
        self.highlight_line = 0

    def run(self):
        """
        Starts the curses interface. This method won't return until
        the user presses a key that terminates the session.
        """

        self._setup_curses()

        try:
            while True:
                self._draw()
                c = self.screen.getch(curses.LINES-1, 1)

                if c == ord('q') or c == ord('Q'):
                    self._teardown_curses()
                    return
                elif c == ord('s'):
                    self._teardown_curses()
                    current_sha = self.file_history.current_commit.sha
                    os.execvp('git', ('git', 'show', current_sha))
                    return
                elif c in key_bindings:
                    getattr(self, key_bindings[c])()
                else:
                    curses.beep()
        except:
            self._teardown_curses()
            raise

    def _setup_curses(self):
        self.screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.screen.keypad(1)

        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(5, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        self.GREEN = curses.color_pair(1)
        self.YELLOW = curses.color_pair(2)
        self.INV_WHITE = curses.color_pair(3)
        self.INV_GREEN = curses.color_pair(4)
        self.INV_YELLOW = curses.color_pair(5)

        self.commits_win = self.screen.subwin(curses.LINES-1, 9, 0, 0)
        self.code_win = self.screen.subwin(curses.LINES-1, curses.COLS-9, 0, 9)
        self.status_win = self.screen.subwin(curses.LINES-2, 0)

    def _teardown_curses(self):
        curses.nocbreak()
        self.screen.keypad(0)
        curses.echo()
        curses.endwin()

    def _draw(self):
        lines = self.file_history.blame()

        start = self.scroll_line
        stop = self.scroll_line + curses.LINES - 2
        visible_lines = lines[start:stop]

        self.commits_win.clear()
        self.code_win.clear()
        for i, line in enumerate(visible_lines):
            if i + start == self.highlight_line:
                commit_color = self.INV_YELLOW
                plus_color = self.INV_GREEN
                code_color = plus_color if line.current else self.INV_WHITE
            else:
                commit_color = self.YELLOW
                plus_color = self.GREEN
                code_color = plus_color if line.current else 0

            self.commits_win.addstr(i, 0, line.sha[:7], commit_color)
            self.commits_win.addstr(i, 7, '  ', code_color)

            cols = curses.COLS - 9
            visible_line = line.line[0:cols].rstrip().ljust(cols, ' ')
            self.code_win.addstr(i, 0, visible_line, code_color)
            if line.current:
                self.commits_win.addstr(i, 7, '+', plus_color)

        self.status_win.clear()
        status = '%s @ %s by %s: ' % (
            self.file_history.path,
            self.file_history.current_commit.sha[:7],
            self.file_history.current_commit.author,
        )
        commit_msg = self.file_history.current_commit.message[:curses.COLS-1]
        self.status_win.addstr(0, 0, status)
        self.status_win.addstr(0, len(status), commit_msg)
        self.status_win.addstr(1, 0, ':')

        self.commits_win.noutrefresh()
        self.code_win.noutrefresh()
        self.status_win.noutrefresh()
        curses.doupdate()

    @bind_keys('j', 'e', curses.KEY_ENTER, curses.KEY_DOWN)
    def down(self, lines=1):
        max_highlight = len(self.file_history.blame()) - 1
        if self.highlight_line >= max_highlight:
            curses.beep()
            return

        self.highlight_line = min(self.highlight_line + lines, max_highlight)

        if self.highlight_line > self.scroll_line + curses.LINES - 3:
            max_scroll_line = self.max_scroll_line()
            self.scroll_line = min(self.scroll_line + lines, max_scroll_line)

    @bind_keys('d')
    def half_page_down(self):
        self.down((curses.LINES - 2) / 2)

    @bind_keys('f', ' ', 'z', curses.KEY_NPAGE)
    def page_down(self):
        self.down(curses.LINES - 2)

    @bind_keys('k', 'y', curses.KEY_UP)
    def up(self, lines=1):
        if self.highlight_line <= 0:
            curses.beep()
            return

        self.highlight_line = max(self.highlight_line - lines, 0)

        if self.highlight_line < self.scroll_line:
            self.scroll_line = self.highlight_line

    @bind_keys('u')
    def half_page_up(self):
        self.up((curses.LINES - 2) / 2)

    @bind_keys('b', 'w', curses.KEY_PPAGE)
    def page_up(self):
        self.up(curses.LINES - 2)

    @bind_keys('g', '<', curses.KEY_HOME)
    def home(self):
        self.scroll_line = 0
        self.highlight_line = 0

    @bind_keys('G', '>', curses.KEY_END)
    def end(self):
        self.scroll_line = self.max_scroll_line()
        self.highlight_line = len(self.file_history.blame()) - 1

    def _move_commit(self, method_name):
        start = self.file_history.current_commit.sha

        method = getattr(self.file_history, method_name)
        if not method():
            curses.beep()
            return

        finish = self.file_history.current_commit.sha

        mapping = self.file_history.line_mapping(start, finish)
        new_highlight_line = mapping.get(self.highlight_line)
        if new_highlight_line is not None:
            self.highlight_line = new_highlight_line

    @bind_keys('n')
    def next_commit(self):
        self._move_commit('next')

    @bind_keys('p')
    def prev_commit(self):
        self._move_commit('prev')

    def max_scroll_line(self):
        lines = self.file_history.blame()
        return len(lines) - curses.LINES + 2


if __name__ == '__main__':
    import argparse
    import textwrap

    parser = argparse.ArgumentParser(
        description=textwrap.dedent('''\
                Browse the Git history of a single file. Similar to
                git blame, but interactive.
            '''),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent('''\
               You can use the following key commands to move around the
               interactive blame output. If you use less they should be
               somewhat familiar:

                j e RETURN DOWN         move down one line
                k y UP                  move up one line
                f z SPACE PAGE-DOWN     move down one screen
                b w PAGE-UP             move up one screen
                d                       move down half a screen
                u                       move up half a screen
                G > END                 move to the bottom of the file
                g < HOME                move to the top of the file

                p                       move to the previous commit
                n                       move to the next commit

                q Q                     quit
                s                       quit, and run `git show`
            '''),
        )
    parser.add_argument('rev', nargs='?', default='HEAD',
                        help='a Git revision to start from (defaults to HEAD)')
    parser.add_argument('file',
                        help='the path to the file you want to examine')
    args = parser.parse_args()

    browser = GitBrowser(args.file, args.rev)
    browser.run()
