#!/usr/bin/env python

import curses
import os

from gitbrowse.ui import ModalTextbox, ModalScrollingInterface


class GitCommit(object):
    """
    Stores simple information about a single Git commit.
    """
    def __init__(self, sha, author, message):
        self.sha = sha
        self.author = author
        self.message = message


class GitBlameLine(object):
    """
    Stores the blame output for a single line of a file.
    """
    def __init__(self, sha, line, current, original_line, final_line):
        self.sha = sha
        self.line = line
        self.current = current
        self.original_line = original_line
        self.final_line = final_line


class GitFileHistory(object):
    """
    Responsible for following the history of a single file, moving around
    within that history, and giving information about the state of the file
    at a particular revision or the differences between revisions.

    Most operations are relative to the current commit, which can be changed
    with the previous and next mthods and accessed through the current_commit
    property.
    """

    def __init__(self, path, start_commit):
        #TODO Validate path
        #TODO Validate commit

        self.path = path

        p = os.popen('git log %s --follow --pretty="%s" -- %s' % (
            start_commit,
            '%H%n%an%n%s%n',
            self.path,
        ))
        output = p.read().split('\n\n')

        self.commits = [GitCommit(*c.split('\n', 2)) for c in output if c]
        self._index = 0
        self._blame = None

        self._line_mappings = {}

    @property
    def current_commit(self):
        return self.commits[self._index]

    def next(self):
        """
        Moves to the next commit that touched this file, returning False
        if we're already at the last commit that touched the file.
        """
        if self._index <= 0:
            return False

        self._index -= 1
        self._blame = None
        return True

    def prev(self):
        """
        Moves to the previous commit that touched this file, returning False
        if we're already at the first commit that touched the file.
        """
        if self._index >= len(self.commits) - 1:
            return False

        self._index += 1
        self._blame = None
        return True

    def blame(self):
        """
        Returns blame information for this file at the current commit as
        a list of GitBlameLine objects.
        """
        if self._blame:
            return self._blame

        lines = []

        p = os.popen('git blame -p %s %s' % (
            self.path,
            self.current_commit.sha,
        ))

        while True:
            header = p.readline()
            if not header:
                break

            # Header format:
            # commit_sha original_line final_line[ lines_in_group]
            sha, original_line, final_line = header.split(' ')[:3]

            line = p.readline()

            # Skip any addition headers describing the commit
            while not line.startswith('\t'):
                line = p.readline()

            lines.append(GitBlameLine(
                sha=sha,
                line=line[1:],
                current=(sha == self.current_commit.sha),
                original_line=original_line,
                final_line=final_line,
            ))

        self._blame = lines
        return self._blame

    def line_mapping(self, start, finish):
        """
        Returns a dict that represents how lines have moved between versions
        of a file. The keys are the line numbers in the version of the file
        at start, the values are where those lines have ended up in the version
        at finish.

        For example if at start the file is two lines, and at
        finish a new line has been inserted between the two the mapping
        would be:
            {1:1, 2:3}

        Deleted lines are represented by None. For example, if at start the
        file were two lines, and the first had been deleted by finish:
            {1:None, 2:1}
        """

        key = start + '/' + finish
        if key in self._line_mappings:
            return self._line_mappings[key]

        forward, backward = self._build_line_mappings(start, finish)
        self._line_mappings[start + '/' + finish] = forward
        self._line_mappings[finish + '/' + start] = backward

        return forward

    def _build_line_mappings(self, start, finish):
        forward = {}
        backward = {}

        p = os.popen('git diff --word-diff=porcelain %s %s -- %s' % (
            start,
            finish,
            self.path,
        ))

        # The diff output is in sections: A header line (indicating the
        # range of lines this section covers) and then a number of
        # content lines.

        sections = []

        # Skip initial headers: They don't interest us.
        line = ''
        while not line.startswith('@@'):
            line = p.readline()

        while line:
            header_line = line
            content_lines = []

            line = p.readline()
            while line and not line.startswith('@@'):
                content_lines.append(line)
                line = p.readline()

            sections.append((header_line, content_lines, ))


        start_ln = finish_ln = 0
        for header_line, content_lines in sections:
            # The headers line has the format '@@ +a,b -c,d @@[ e]' where
            # a is the first line number shown from start and b is the
            # number of lines shown from start, and c is the first line
            # number show from finish and d is the number of lines show
            # from from finish, and e is Git's guess at the name of the
            # context (and is not always present)

            headers = header_line.strip('@ \n').split(' ')
            headers = map(lambda x: x.strip('+-').split(','), headers)

            start_range = map(int, headers[0])
            finish_range = map(int, headers[1])

            while start_ln < start_range[0] - 1 and \
                  finish_ln < finish_range[0] - 1:
                forward[start_ln] = finish_ln
                backward[finish_ln] = start_ln
                start_ln += 1
                finish_ln += 1

            # Now we're into the diff itself. Individual lines of input
            # are separated by a line containing only a '~', this helps
            # to distinguish between an addition, a removal, and a change.

            line_iter = iter(content_lines)
            try:
                while True:
                    line_delta = 0
                    line = ' '
                    while line != '~':
                        if line.startswith('+'):
                            line_delta += 1
                        elif line.startswith('-'):
                            line_delta -= 1

                        line = line_iter.next().rstrip()

                    if line_delta == 1:
                        backward[finish_ln] = None
                        finish_ln += 1
                    elif line_delta == -1:
                        forward[start_ln] = None
                        start_ln += 1
                    else:
                        forward[start_ln] = finish_ln
                        backward[finish_ln] = start_ln
                        start_ln += 1
                        finish_ln += 1
            except StopIteration:
                pass

        # Make sure the mappings stretch the the beginning and end of
        # the files.

        p = os.popen('git show %s:%s' % (start, self.path))
        start_len = len(p.readlines())

        p = os.popen('git show %s:%s' % (finish, self.path))
        finish_len = len(p.readlines())

        while start_ln <= start_len and finish_ln <= finish_len:
            forward[start_ln] = finish_ln
            backward[finish_ln] = start_ln
            start_ln += 1
            finish_ln += 1

        return forward, backward


class GitBrowser(ModalScrollingInterface):
    """
    Provides the user interface for the git browse tool.
    """

    exit_keys = ModalScrollingInterface.exit_keys + (ord('s'), )
    modes = {
        '/': 'search',
        '?': 'reverse_search',
    }

    def __init__(self, path, commit):
        super(GitBrowser, self).__init__()
        self.file_history = GitFileHistory(path, commit)
        self.search_term = None
        self.reverse_search = False

    def content(self):
        return self.file_history.blame()

    def draw_content_line(self, line, row, window, highlight):
        if highlight:
            commit_color = self.INV_YELLOW
            code_color = self.INV_GREEN if line.current else self.INV_WHITE
            search_result_color = 0
        else:
            commit_color = self.YELLOW
            code_color = self.GREEN if line.current else 0
            search_result_color = self.INV_WHITE

        window.addstr(row, 0, line.sha[:7], commit_color)
        window.addstr(row, 7, '+ ' if line.current else '  ', code_color)

        cols = curses.COLS - 9
        padded_line = line.line[:cols].rstrip().ljust(cols, ' ')
        window.addstr(row, 9, padded_line, code_color)

        if self.search_term:
            search_start = 0
            try:
                while True:
                    index = line.line.index(self.search_term, search_start)
                    search_start = index + len(self.search_term)
                    window.addstr(row, 9+index, self.search_term,
                                  search_result_color)
            except ValueError:
                pass

    def finalise(self, exit_key):
        if exit_key == ord('s'):
            current_sha = self.file_history.current_commit.sha
            os.execvp('git', ('git', 'show', current_sha))

    def handle_input(self, mode, data):
        if mode == 'search' or mode == 'reverse_search':
            self.search_term = data
            self.reverse_search = (mode == 'reverse_search')
            self.next_search_match()
            self._draw()

    def get_status(self):
        return '%s @ %s by %s: %s' % (
            self.file_history.path,
            self.file_history.current_commit.sha[:7],
            self.file_history.current_commit.author,
            self.file_history.current_commit.message,
        )

    def _move_commit(self, method_name):
        start = self.file_history.current_commit.sha

        method = getattr(self.file_history, method_name)
        if not method():
            curses.beep()
            return

        finish = self.file_history.current_commit.sha

        mapping = self.file_history.line_mapping(start, finish)
        new_highlight_line = mapping.get(self.highlight_line)
        if new_highlight_line is not None:
            self.highlight_line = new_highlight_line
        else:
            # The highlight_line setter validates the value, so it makes
            # sense to set it to the same value here to make sure that it's
            # not out of range for the newly loaded revision of the file.
            self.highlight_line = self.highlight_line

    @ModalScrollingInterface.key_bindings('[')
    def next_commit(self, times=1):
        for i in range(0,times):
            self._move_commit('next')

    @ModalScrollingInterface.key_bindings(']')
    def prev_commit(self, times=1):
        for i in range(0,times):
            self._move_commit('prev')

    def _next_search_match(self, times=1):
        if not self.search_term:
            curses.beep()
            return

        moved = False
        for n in range(0,times):
            possible_matches = self.content()[self.highlight_line + 1:]
            for i, line in enumerate(possible_matches):
                if self.search_term in line.line:
                    self.highlight_line += i + 1
                    moved = True
                    break

        if not moved:
            curses.beep()

    def _prev_search_match(self, times=1):
        if not self.search_term:
            curses.beep()
            return

        moved = False
        for n in range(0,times):
            possible_matches = self.content()[:self.highlight_line]
            for i, line in enumerate(reversed(possible_matches)):
                if self.search_term in line.line:
                    self.highlight_line -= i + 1
                    moved = True
                    break

        if not moved:
            curses.beep()

    @ModalScrollingInterface.key_bindings('n')
    def next_search_match(self, times=1):
        if self.reverse_search:
            self._prev_search_match(times)
        else:
            self._next_search_match(times)

    @ModalScrollingInterface.key_bindings('N')
    def prev_search_match(self, times=1):
        if self.reverse_search:
            self._next_search_match(times)
        else:
            self._prev_search_match(times)


if __name__ == '__main__':
    import argparse
    import textwrap

    parser = argparse.ArgumentParser(
        description=textwrap.dedent('''\
                Browse the Git history of a single file. Similar to
                git blame, but interactive.
            '''),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent('''\
               You can use the following key commands to move around the
               interactive blame output. If you use less they should be
               somewhat familiar:

               NAVIGATING AROUND THE FILE:
                j e RETURN DOWN         move down one line
                k y UP                  move up one line
                f z SPACE PAGE-DOWN     move down one screen
                b w PAGE-UP             move up one screen
                d                       move down half a screen
                u                       move up half a screen
                G > END                 move to the bottom of the file
                g < HOME                move to the top of the file

               NAVIGATING GIT HISTORY:
                [                       move to the previous commit
                ]                       move to the next commit

               SEARCH:
                /                       search forwards through file
                ?                       search backwards through file
                n                       go to next match
                N                       go to previous match

               QUITTING:
                q Q                     quit
                s                       quit, and run `git show`
            '''),
        )
    parser.add_argument('rev', nargs='?', default='HEAD',
                        help='a Git revision to start from (defaults to HEAD)')
    parser.add_argument('file',
                        help='the path to the file you want to examine')
    args = parser.parse_args()

    browser = GitBrowser(args.file, args.rev)
    browser.run()
